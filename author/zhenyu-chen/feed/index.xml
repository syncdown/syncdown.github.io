<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Zhenyu Chen</title>
	<atom:link href="https://syncdown.github.io/author/zhenyu-chen/feed/" rel="self" type="application/rss+xml" />
	<link>https://syncdown.github.io/</link>
	<description></description>
	<lastBuildDate>Thu, 18 Jul 2024 12:23:05 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.5.5</generator>

<image>
	<url>https://syncdown.github.io/wp-content/uploads/2024/04/syncdown-150x150.png</url>
	<title>Zhenyu Chen</title>
	<link>https://syncdown.github.io/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>方法中返回局部变量地址，方便和内存逃逸怎么选？</title>
		<link>https://syncdown.github.io/%e6%96%b9%e6%b3%95%e4%b8%ad%e8%bf%94%e5%9b%9e%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e5%9c%b0%e5%9d%80%ef%bc%8c%e6%96%b9%e4%be%bf%e5%92%8c%e5%86%85%e5%ad%98%e9%80%83%e9%80%b8%e6%80%8e%e4%b9%88%e9%80%89/</link>
		
		<dc:creator><![CDATA[Zhenyu Chen]]></dc:creator>
		<pubDate>Thu, 18 Jul 2024 12:23:05 +0000</pubDate>
				<category><![CDATA[技术]]></category>
		<category><![CDATA[golang]]></category>
		<category><![CDATA[内存逃逸]]></category>
		<guid isPermaLink="false">https://syncdown.github.io/?p=253</guid>

					<description><![CDATA[在 Go 语言中，内存逃逸有好多种情况， 其中最常见的一种就是方法中返回了局部变量的地址。 内存逃逸是指在函数内部创建的变量，其生命周期超出了函数的范围，被分配到堆上而不是栈上。一般情况下，局部变量会被分配到栈上，函数执行结束后会自动释放栈空间。然而，如果函数返回了局部变量的地址，并且该地址在函数外部被使用，那么这个局部变量就不能在函数结束时被释放，因此需要将其分配到堆上，以保证其生命周期的延续性。 [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>在 Go 语言中，内存逃逸有好多种情况， 其中最常见的一种就是方法中返回了局部变量的地址。</p>



<blockquote class="wp-block-quote is-layout-flow wp-block-quote-is-layout-flow">
<p>内存逃逸是指在函数内部创建的变量，其生命周期超出了函数的范围，被分配到堆上而不是栈上。一般情况下，局部变量会被分配到栈上，函数执行结束后会自动释放栈空间。然而，如果函数返回了局部变量的地址，并且该地址在函数外部被使用，那么这个局部变量就不能在函数结束时被释放，因此需要将其分配到堆上，以保证其生命周期的延续性。</p>
</blockquote>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">func memoryLeak() *xyz {
	return &amp;xyz{}
}</pre>



<p>原因就是因为返回的地址被方法外部所使用，那么这个局部变量就不能再函数结束的时候被释放，在编译时就将其分配到堆上，需要在运行时靠垃圾回收机制才能释放内存。</p>



<p>那如果不返回地址，而是返回值类型变量，是不是就避免了内存逃逸问题呢？</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">type myStructure struct {
	Name    string
	Surname string
	Height  int32
}

// 引发内存逃逸
func NewStructurePointer(n, s string, h int32) *myStructure {
	if h > 300 {
		h = 0
	}
	return &amp;myStructure{n, s, h}
}

// 返回值类型，避免内存逃逸
func NewStructure(n, s string, h int32) myStructure {
	if h > 300 {
		h = 0
	}
	return myStructure{n, s, h}
}</pre>



<p>如果调用NewStructurePointer方法，编译的时候进行一下逃逸分析就知道了，(*s1).Name escapes to heap， 很明显会指出具体的变量会逃逸到堆中。 </p>



<figure class="wp-block-image size-large"><img fetchpriority="high" decoding="async" width="1024" height="635" src="https://syncdown.github.io/wp-content/uploads/2024/07/image-1024x635.png" alt="" class="wp-image-254" srcset="https://syncdown.github.io/wp-content/uploads/2024/07/image-1024x635.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/07/image-300x186.png 300w, https://syncdown.github.io/wp-content/uploads/2024/07/image-768x477.png 768w, https://syncdown.github.io/wp-content/uploads/2024/07/image-1536x953.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/07/image.png 1834w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>如果调用NewStructure方法， 再来看一下。</p>



<figure class="wp-block-image size-large"><img decoding="async" width="1024" height="885" src="https://syncdown.github.io/wp-content/uploads/2024/07/image-1-1024x885.png" alt="" class="wp-image-255" srcset="https://syncdown.github.io/wp-content/uploads/2024/07/image-1-1024x885.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/07/image-1-300x259.png 300w, https://syncdown.github.io/wp-content/uploads/2024/07/image-1-768x664.png 768w, https://syncdown.github.io/wp-content/uploads/2024/07/image-1-1536x1327.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/07/image-1.png 1650w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>曾经一概而论NewStructPointer因为返回的是指针方便操作，而对它青睐有加。兜兜转转目前看上去还是NewStrcut返回值类型这样的方法签名更好一些，返璞归真，也更具备更好的可读性。</p>



<figure class="wp-block-image size-large"><img decoding="async" width="1024" height="290" src="https://syncdown.github.io/wp-content/uploads/2024/07/image-2-1024x290.png" alt="" class="wp-image-257" srcset="https://syncdown.github.io/wp-content/uploads/2024/07/image-2-1024x290.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/07/image-2-300x85.png 300w, https://syncdown.github.io/wp-content/uploads/2024/07/image-2-768x218.png 768w, https://syncdown.github.io/wp-content/uploads/2024/07/image-2.png 1404w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>结论：</p>



<ol>
<li>方法中的局部变量直接返回地址是会造成内存逃逸的。</li>



<li>如果方法直接返回值类型的变量，就没有内存逃逸的风险。</li>



<li>内存逃逸分析是编译阶段。</li>



<li>内存释放是运行阶段的事情。</li>



<li>相比于指针类型返回的方法，更建议平时写代码返回值类型的。避免内存逃逸，可读性也更好一些。</li>
</ol>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>go中的defer</title>
		<link>https://syncdown.github.io/go%e4%b8%ad%e7%9a%84defer/</link>
		
		<dc:creator><![CDATA[Zhenyu Chen]]></dc:creator>
		<pubDate>Tue, 16 Jul 2024 07:25:58 +0000</pubDate>
				<category><![CDATA[技术]]></category>
		<category><![CDATA[defer]]></category>
		<category><![CDATA[golang]]></category>
		<guid isPermaLink="false">https://syncdown.github.io/?p=242</guid>

					<description><![CDATA[说起defer ， 用go进行开发的工程师肯定不会陌生。 粗浅的说，是用先进后出的方式，在方法返回的时刻进行执行statement的关键字。 官方文档：“A [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>说起defer ， 用go进行开发的工程师肯定不会陌生。 </p>



<p>粗浅的说，是用先进后出的方式，在方法返回的时刻进行执行statement的关键字。 </p>



<blockquote class="wp-block-quote is-layout-flow wp-block-quote-is-layout-flow">
<p>官方文档：“A “defer” statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.”<br>即函数返回、函数结束或者对应的goroutine发生panic时defer执行。</p>



<p>关键词：surrounding function，returns，end of its function body, goroutine panicking</p>
</blockquote>



<p>确实，之前总是狭隘的认为就方法return的时刻，没有想到panic的情况， 是记不准确也不全面。 </p>



<ol>
<li>defer运行的时机</li>
</ol>



<ul>
<li>说法一：defer的运行时机是方法返回结束之后，返回之前。</li>



<li>说法二：既然是defer那么就有外围方法和当前方法的区别，是当前方法返回之后，外围方法执行之前。</li>



<li>不管是哪种说法，写代码验证一下就好。</li>
</ul>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">package main

import "fmt"

func external() {
	fmt.Println("external is starting")
	internal()
	fmt.Println("external is ending")
}

func internal() {
	fmt.Println("internal is starting")
	defer func() {
		fmt.Println("internal defer is executing")
	}()
	fmt.Println("internal is ending")

}
func main() {
	external()
}
</pre>



<p>执行结果</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">external is starting
internal is starting
internal is ending
internal defer is executing
external is ending</pre>



<p>defer执行的时机，<strong>是在当法return或语句结束之后，而在方法真正退出之前</strong>。</p>



<p>2. 多个defer的执行顺序-后入先出。即LIFO</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">package main

import (
    "fmt"
)

func main() {
    defer fmt.Println("main defer1")
    test()
    defer fmt.Println("main defer2")
}

func test() () {
    defer func() {
        fmt.Println("test defer1")
    }()
    defer func() {
        fmt.Println("test defer2")
    }()
}
</pre>



<p>执行结果</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">test defer2
test defer1
main defer2
main defer1</pre>



<p>当多个defer的时候，就像栈一样，有压栈和出栈，其实是当前goroutine的defer链。执行的<strong>顺序是LIFO</strong>，最后压栈的会第一个执行。</p>



<p>3.除了return，当出现panic的时候defer也会被触发执行。</p>



<p>defer这个用处就非常大了，当然也得交代一下其他的背景。</p>



<ul>
<li><code>panic</code> 能够改变程序的控制流，调用 <code>panic</code> 后会立刻停止执行当前函数的剩余代码，并在当前 Goroutine 中递归执行调用<code>defer</code>；</li>



<li><code>recover</code> 可以中止 <code>panic</code> 造成的程序崩溃。它是一个只能在 <code>defer</code> 中发挥作用的函数，在其他作用域中调用不会发挥作用；</li>
</ul>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">func try(f func()) {
    defer func() {
        if err := recover(); err != nil {
            fmt.Println("caught panic:", err)
        }
    }()
    f()
}</pre>



<p>一般会封装一个<strong>try或者myRecover</strong>的方法，传入参数是自定义的方法。先defer后再执行自定义方法，recover一定要在defer中才能发挥作用。</p>



<p>总结：</p>



<ol>
<li>defer的执行时机是方法return之后，真正退出之前。</li>



<li>多个defer的顺序是LIFO，类似于栈。</li>



<li>封装myRcover方法，传入参数是自定义方法。当自定义方法出现panic，在defer中会用recover中止程序崩溃。（<strong>defer机制的执行顺序决定了是自定义方法panic之后程序会捕获，recover起到了中止程序崩溃的作用</strong>）</li>
</ol>



<p></p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>保持人物一致性</title>
		<link>https://syncdown.github.io/%e4%bf%9d%e6%8c%81%e4%ba%ba%e7%89%a9%e4%b8%80%e8%87%b4%e6%80%a7/</link>
		
		<dc:creator><![CDATA[Zhenyu Chen]]></dc:creator>
		<pubDate>Wed, 26 Jun 2024 08:59:31 +0000</pubDate>
				<category><![CDATA[技术]]></category>
		<category><![CDATA[comfyui]]></category>
		<category><![CDATA[人物一致性]]></category>
		<guid isPermaLink="false">https://syncdown.github.io/?p=230</guid>

					<description><![CDATA[保持人物一致性有很多， 有的是图生图来保持一致性，有的是文生图来保持一致性。后者更无中生、天马行空一些。 关于文生图来保持人物一致性，这里说的思路是固定模型，固定种子的情况下，批量生成多张人物图片而保持一致性。 seed决定了图片的构图， 比如效果如下 [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>保持人物一致性有很多， 有的是图生图来保持一致性，有的是文生图来保持一致性。后者更无中生、天马行空一些。</p>



<p>关于文生图来保持人物一致性，这里说的思路是固定模型，固定种子的情况下，批量生成多张人物图片而保持一致性。</p>



<p>seed决定了图片的构图，</p>



<p>比如效果如下</p>



<ul>
<li>模型：ArienmixxlAsian（主打亚洲人像脸部特征）</li>



<li>vae：sdxl_vae.safetensors</li>



<li>lora：lcm</li>



<li>输入8个不同的表情</li>



<li>用简单的几何形状构成的底图来绘制不同图片人物的大小和相对位置</li>
</ul>



<div class="wp-block-columns is-layout-flex wp-container-core-columns-is-layout-1 wp-block-columns-is-layout-flex">
<div class="wp-block-column is-layout-flow wp-block-column-is-layout-flow">
<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1004" height="1024" src="https://syncdown.github.io/wp-content/uploads/2024/06/image-8-1004x1024.png" alt="" class="wp-image-232" srcset="https://syncdown.github.io/wp-content/uploads/2024/06/image-8-1004x1024.png 1004w, https://syncdown.github.io/wp-content/uploads/2024/06/image-8-294x300.png 294w, https://syncdown.github.io/wp-content/uploads/2024/06/image-8-768x784.png 768w, https://syncdown.github.io/wp-content/uploads/2024/06/image-8.png 1182w" sizes="(max-width: 1004px) 100vw, 1004px" /></figure>



<p>提示词prompt</p>



<p>1girl</p>
</div>



<div class="wp-block-column is-layout-flow wp-block-column-is-layout-flow">
<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="966" height="1024" src="https://syncdown.github.io/wp-content/uploads/2024/06/image-9-966x1024.png" alt="" class="wp-image-233" srcset="https://syncdown.github.io/wp-content/uploads/2024/06/image-9-966x1024.png 966w, https://syncdown.github.io/wp-content/uploads/2024/06/image-9-283x300.png 283w, https://syncdown.github.io/wp-content/uploads/2024/06/image-9-768x814.png 768w, https://syncdown.github.io/wp-content/uploads/2024/06/image-9.png 1124w" sizes="(max-width: 966px) 100vw, 966px" /></figure>



<p>提示词prompt</p>



<p>The image showcases a close-up portrait of a young woman with an ethereal appearance. She possesses long, dark hair that cascades down her shoulders and is adorned with what seems to be a sheer scarf or veil blending into the background. Her complexion is impeccable, complemented by subtle makeup featuring earthy tones on her eyelids and a soft peach hue on her lips. She rests her face gently in her hand, exuding serenity and poise.</p>
</div>
</div>



<p>所以这个思路就是，通过不用表情及人物大小和头部位置做差异化， 保持seed和其他因子保持不变来保证人物一致性。</p>



<h2 class="wp-block-heading">如何控制不同的面部表情</h2>



<p>利用多行文本text multiline这个节点，每行输入一个表情描述，比如微笑、满足、激动、生气、烦乱、忧郁、焦虑、不安</p>



<p>后面组成的prompt会用逗号分隔符把其他的拼接起来。不过话说，我确实没看出来这每张图片对应的表情，似乎都面无表情。</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="528" src="https://syncdown.github.io/wp-content/uploads/2024/06/image-10-1024x528.png" alt="" class="wp-image-235" srcset="https://syncdown.github.io/wp-content/uploads/2024/06/image-10-1024x528.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/06/image-10-300x155.png 300w, https://syncdown.github.io/wp-content/uploads/2024/06/image-10-768x396.png 768w, https://syncdown.github.io/wp-content/uploads/2024/06/image-10-1536x792.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/06/image-10.png 1560w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<h2 class="wp-block-heading">如何控制每张图中的人物大小和相对位置</h2>



<p>分别沿着x和y的方向，从0开始按照步长25进行遍历，最终是200，那么意味着总共8张图片（violet藕粉色的背景，星星图案），这里底图的数量8和表情数量要一致。</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="500" src="https://syncdown.github.io/wp-content/uploads/2024/06/image-11-1024x500.png" alt="" class="wp-image-236" srcset="https://syncdown.github.io/wp-content/uploads/2024/06/image-11-1024x500.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/06/image-11-300x147.png 300w, https://syncdown.github.io/wp-content/uploads/2024/06/image-11-768x375.png 768w, https://syncdown.github.io/wp-content/uploads/2024/06/image-11-1536x750.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/06/image-11.png 1818w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<h2 class="wp-block-heading">融合底图和提示词的主要流程</h2>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="392" src="https://syncdown.github.io/wp-content/uploads/2024/06/image-12-1024x392.png" alt="" class="wp-image-237" srcset="https://syncdown.github.io/wp-content/uploads/2024/06/image-12-1024x392.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/06/image-12-300x115.png 300w, https://syncdown.github.io/wp-content/uploads/2024/06/image-12-768x294.png 768w, https://syncdown.github.io/wp-content/uploads/2024/06/image-12-1536x587.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/06/image-12-2048x783.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>golang并发中的cond</title>
		<link>https://syncdown.github.io/golang%e5%b9%b6%e5%8f%91%e4%b8%ad%e7%9a%84cond/</link>
		
		<dc:creator><![CDATA[Zhenyu Chen]]></dc:creator>
		<pubDate>Tue, 11 Jun 2024 06:29:06 +0000</pubDate>
				<category><![CDATA[技术]]></category>
		<category><![CDATA[cond]]></category>
		<category><![CDATA[golang]]></category>
		<guid isPermaLink="false">https://syncdown.github.io/?p=212</guid>

					<description><![CDATA[概览 cond应该是condition的缩写，它是goroutine的集合点，等待或发布一个event。 event就是两个或两个以上的goroutine之间的任意事件信号。 用来解决多个读协程等待共享资源变成ready的场景，和waitgroup很像，如果把waitgroup比作多匹赛马等待发令枪，waitgroup十分关心数量，而cond关心的则是条件。 使用场景的区别 [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p class="has-larger-font-size">概览</p>



<p>cond应该是condition的缩写，它是goroutine的集合点，等待或发布一个event。</p>



<p>event就是两个或两个以上的goroutine之间的任意事件信号。</p>



<p>用来解决多个读协程等待共享资源变成ready的场景，和waitgroup很像，如果把waitgroup比作多匹赛马等待发令枪，waitgroup十分关心数量，而cond关心的则是条件。</p>



<p>使用场景的区别</p>



<ul>
<li>waitgroup：赛马等待发令枪，关心数量</li>



<li>cond
<ul>
<li>broadcast赛马等待发令枪，但是不太关系赛马的数量。</li>



<li>signal多辆车在单车道等红灯 或者 火车站的办事窗口-办完一个通知下一个，按照FIFO的顺序。</li>
</ul>
</li>
</ul>



<p class="has-larger-font-size">cond中的Wait和Broadcast</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">package main

import (
	"fmt"
	"sync"
	"time"
)

var shared = false

func main() {
	wg := sync.WaitGroup{}
	// 构造cond对象，需要关联一把锁
	c := sync.NewCond(&amp;sync.Mutex{})

	// 两辆车在等红灯（两个协程读取共享变量）
	for i := 0; i &lt; 2; i++ {
		wg.Add(1)
		go func(i int) {
			c.L.Lock()
			// 红灯的情况
			// for !share{ 用for还是if，其实窦性，关键的是c.Wait()
			if !shared {
				fmt.Printf("time:%v goroutine %v wait\n", time.Now(), i)
				c.Wait()
			}
			// 绿灯的情况
			fmt.Printf("time:%v goroutine %v shared:%v\n", time.Now(), i, shared)
			c.L.Unlock()
			wg.Done()
		}(i)
	}

	// 管理红绿灯的控制程序
	time.Sleep(time.Second * 2)
	c.L.Lock()
	fmt.Printf("time:%v goroutine main ready\n", time.Now())
	shared = true
	c.Broadcast()
	fmt.Printf("time:%v goroutine main broadcast\n", time.Now())
	c.L.Unlock()

	// 让main这个子弹飞一会，不然会直接退出
	wg.Wait()

}
</pre>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="178" src="https://syncdown.github.io/wp-content/uploads/2024/06/image-4-1024x178.png" alt="" class="wp-image-214" srcset="https://syncdown.github.io/wp-content/uploads/2024/06/image-4-1024x178.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/06/image-4-300x52.png 300w, https://syncdown.github.io/wp-content/uploads/2024/06/image-4-768x133.png 768w, https://syncdown.github.io/wp-content/uploads/2024/06/image-4.png 1508w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p><strong>两辆车一先一后在单行道上等待红灯，绿灯亮起后，先后读取到通行信号出发。</strong></p>



<p>小结：</p>



<ul>
<li>cond需要关联一把锁，可以是Mutex也可是RWMutex</li>



<li>不论是车还是红灯管理程序，读写共享变量都需要针对条件锁里面关联</li>



<li>cond的Wait()，#车要等待</li>



<li>cond的Broadcast() #红灯管理程序要广播，让车辆看得见。</li>
</ul>



<p class="has-larger-font-size">cond中的Wait和Signal</p>



<p>场景类比，单个窗口的派对，协程通过共享变量的读取竞争来获得执行权，谁先得到谁执行。</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">package main

import (
	"fmt"
	"sync"
	"time"
)

var shared = false

func main() {
	wg := sync.WaitGroup{}
	c := sync.NewCond(&amp;sync.Mutex{})
	for i := 0; i &lt; 2; i++ {
		wg.Add(1)
		go func(i int) {
			c.L.Lock()
			for !shared {
				fmt.Printf("time:%v goroutine %v wait\n", time.Now(), i)
				c.Wait()
			}
			fmt.Printf("time:%v goroutine %v shared:%v\n", time.Now(), i, shared)
			c.L.Unlock()
			wg.Done()
		}(i)
	}

	for i := 0; i &lt; 2; i++ {
		time.Sleep(time.Second * 2)
		c.L.Lock()
		fmt.Printf("time:%v main goroutine %v ready\n ", time.Now(), i)
		shared = true
		c.Signal()
		fmt.Printf("time:%v main goroutine %v signal\n", time.Now(), i)
		c.L.Unlock()
	}

	wg.Wait()
}
</pre>



<p>结果</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="241" src="https://syncdown.github.io/wp-content/uploads/2024/06/image-5-1024x241.png" alt="" class="wp-image-217" srcset="https://syncdown.github.io/wp-content/uploads/2024/06/image-5-1024x241.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/06/image-5-300x70.png 300w, https://syncdown.github.io/wp-content/uploads/2024/06/image-5-768x180.png 768w, https://syncdown.github.io/wp-content/uploads/2024/06/image-5.png 1456w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>当监听的对象是队列的时候</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	c := sync.NewCond(&amp;sync.Mutex{})
	// 长度为零，容量为10的切片
	queue := make([]interface{}, 0, 10)

	addToQueue := func() {
		var i int
		for {
			c.L.Lock()
			// 队列大于等于3的时候就会停住，只要小于3写入队列就会很快 #快入#
			for len(queue) >= 3 {
				fmt.Printf("the size of queue is %d\n", len(queue))
				c.Wait()
			}
			fmt.Printf("Add to queue by %v\n", i)
			queue = append(queue, i)
			c.L.Unlock()
			c.Signal()
			i++
		}
	}

	removeFromQueue := func(delay time.Duration) {
		for {
			time.Sleep(delay)
			c.L.Lock()
			removed := queue[0]
			queue = queue[1:]
			fmt.Printf("Removed %v from queue\n", removed)
			c.L.Unlock()
			c.Signal()
		}
	}

	// 队列大于等于3的时候就会停住，只要小于3写入队列就会很快 #快入#
	go addToQueue()

	// 间隔一秒移除队列一项 #慢出#
	go removeFromQueue(1 * time.Second)

	var ch chan struct{}
	&lt;-ch
}
</pre>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="918" height="490" src="https://syncdown.github.io/wp-content/uploads/2024/06/image-6.png" alt="" class="wp-image-222" srcset="https://syncdown.github.io/wp-content/uploads/2024/06/image-6.png 918w, https://syncdown.github.io/wp-content/uploads/2024/06/image-6-300x160.png 300w, https://syncdown.github.io/wp-content/uploads/2024/06/image-6-768x410.png 768w" sizes="(max-width: 918px) 100vw, 918px" /></figure>



<p>因为队列是快入慢出的， 并且以3为阈值，大于等于3就停止写入。所以开始很快的写入队列三个数据，后来只能走一个进一个。</p>



<h2 class="wp-block-heading">cond的更合理的用法</h2>



<ol>
<li>把要监听的事件或者条件抽象成struct中的字段</li>



<li>对业务处理方法作为参数传入到订阅方法里面，在独立的goroutine中，在合适的时机运行它</li>
</ol>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">package main

import (
	"fmt"
	"sync"
)

type Button struct {
	Clicked *sync.Cond
	//  other attributes，当前演示的是Buttone的点击事件，当然可以有别的事件
}

func main() {
	// 定义一个Button类型，包含一个clicked条件
	button := Button{Clicked: sync.NewCond(&amp;sync.Mutex{})}
	// 定义便利构造函数，允许注册函数监听信号，在合适的时机进行业务处理
	// 每个处理程序都独立在自己的goroutine上，订阅不会退出，直到goroutine被确认运行为止
	subscribe := func(c *sync.Cond, fn func()) {
		var goroutineRunning sync.WaitGroup
		goroutineRunning.Add(1)
		go func() {
			goroutineRunning.Done()
			c.L.Lock()
			defer c.L.Unlock()
			c.Wait()
			fn()
		}()
		goroutineRunning.Wait()
	}

	var clickRegistered sync.WaitGroup
	clickRegistered.Add(3)
	subscribe(button.Clicked, func() {
		fmt.Println("Maximizing windows")
		clickRegistered.Done()
	})
	subscribe(button.Clicked, func() {
		fmt.Println("Displaying anyting in windows")
		clickRegistered.Done()
	})
	subscribe(button.Clicked, func() {
		fmt.Println("Mouse cliked")
		clickRegistered.Done()
	})
	button.Clicked.Broadcast()
	clickRegistered.Wait()
}
</pre>



<p></p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>golang中的深拷贝</title>
		<link>https://syncdown.github.io/golang%e4%b8%ad%e7%9a%84%e6%b7%b1%e6%8b%b7%e8%b4%9d/</link>
		
		<dc:creator><![CDATA[Zhenyu Chen]]></dc:creator>
		<pubDate>Sun, 02 Jun 2024 09:32:51 +0000</pubDate>
				<category><![CDATA[技术]]></category>
		<category><![CDATA[golang]]></category>
		<category><![CDATA[深拷贝]]></category>
		<guid isPermaLink="false">https://syncdown.github.io/?p=187</guid>

					<description><![CDATA[相信大家都有过这样的经历，生活中的打印和复印，一般都是打印贵，复印便宜。为了更节约成本，会先打印一份，然后把这份纸质文稿再复印几份。 打印很像原型实例化的过程(from struct)，而复印特别像原型拷贝的过程(from seed instance)。 [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>相信大家都有过这样的经历，生活中的打印和复印，一般都是打印贵，复印便宜。为了更节约成本，会先打印一份，然后把这份纸质文稿再复印几份。</p>



<p>打印很像<strong>原型实例化的过程</strong>(from struct)，而复印特别像<strong>原型拷贝的过程</strong>(from seed instance)。</p>



<p>区别就在于，对于某些语言比如java，如果是原型实例化的过程可能很耗时，而拥有一个实例把它作为种子或者模板进行拷贝，这个过程可能既简单又快速。而golang连赋值都是值传递，值拷贝，所以要做到深拷贝还是很容易的。</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// golang这门语言的赋值都是值传递，如果结构中不含指针，那么直接复制就是深拷贝
func DeepCopy(src Person) Person {
	return Person{Name: src.Name, Age: src.Age}
}</pre>



<p>测试文件</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">package Solution

import (
	"fmt"
	"reflect"
	"runtime"
	"strings"
	"testing"
	"unsafe"

	"github.com/davecgh/go-spew/spew"
	"github.com/stretchr/testify/assert"
)

type SolutionFuncType func(src Person) Person

var SolutionFuncTypeList = []SolutionFuncType{
	DeepCopy,
}

type Case struct {
	caseName string
	input    Person
}

var cases = []Case{
	{"normal", Person{Name: "mike", Age: 10}},
}

func TestDeepCopy(t *testing.T) {
	ast := assert.New(t)

	for _, f := range SolutionFuncTypeList {
		funcName := strings.Split(runtime.FuncForPC(reflect.ValueOf(f).Pointer()).Name(), ".")[1]
		spew.Dump(funcName)
		for _, c := range cases {
			t.Run(fmt.Sprintf("%s %s", funcName, c.caseName), func(t *testing.T) {
				output := f(c.input)
				ast.Equal(c.input, output, "func:%s case:%s", funcName, c.caseName)
				ast.NotEqual(unsafe.Pointer(&amp;c.input), unsafe.Pointer(&amp;output))
			})
		}
	}
}</pre>



<p>反思自己，之前也有项目中间需要不断进行实例化的场景，如果是分布式的话就不得不进行类似于json的encode decode，当然gob也可以，会稍微快一点，但是就不太好进行日志打印了，因为一般公司都是以json的格式进行日志处理的。</p>



<p>如果没有跨机器实例，直接从已有的instance进行实例化也不妨是一种好办法。</p>



<p>如下，举个例子，最上层的struct既包含值类型的字段Name Age，也包含指针类型的字段ParentInfo。对于这种原型已有的实例进行深拷贝。</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">type Person struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

type ParentInfo struct {
	Father string `json:"father"`
	Mother string `json:"mother"`
}

type PersonWithPointer struct {
	Person                // anonymous field
	ParentInfo ParentInfo `json:"parent_info"`
}

func DeepCopyPersonWithPointer(src PersonWithPointer) PersonWithPointer {
	dst := PersonWithPointer{}
	dst.Age = src.Age
	dst.Name = src.Name

	parentInfo := ParentInfo{Father: src.ParentInfo.Father, Mother: src.ParentInfo.Mother}
	dst.ParentInfo = parentInfo
	return dst
}

func DeepCopyPersonWithPointerByJson(src PersonWithPointer) PersonWithPointer {
	dst := PersonWithPointer{}
	bytes, err := json.Marshal(src)
	if err != nil {
		panic(err)
	}
	err = json.Unmarshal(bytes, &amp;dst)
	if err != nil {
		panic(err)
	}
	return dst
}</pre>



<p>对应的单元测试代码</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">type SolutionFuncType1 func(src PersonWithPointer) PersonWithPointer

var SolutionFuncTypeList1 = []SolutionFuncType1{
	DeepCopyPersonWithPointer,
	DeepCopyPersonWithPointerByJson,
}

type Case1 struct {
	caseName string
	input    PersonWithPointer
}

var cases1 = []Case1{
	{"normal", PersonWithPointer{Person: Person{Name: "zhangsan", Age: 20}, ParentInfo: ParentInfo{Father: "zhanger", Mother: "wanglili"}}},
}

func TestDeepCopyWithPointer(t *testing.T) {
	ast := assert.New(t)

	for _, f := range SolutionFuncTypeList1 {
		funcName := strings.Split(runtime.FuncForPC(reflect.ValueOf(f).Pointer()).Name(), ".")[1]
		for _, c := range cases1 {
			t.Run(fmt.Sprintf("%s %s", funcName, c.caseName), func(t *testing.T) {
				output := f(c.input)
				ast.Equal(c.input, output, "func:%s case:%s", funcName, c.caseName)
				ast.NotEqual(unsafe.Pointer(&amp;c.input), unsafe.Pointer(&amp;output))
			})
		}
	}
}</pre>



<p>既然利用已有的instance有两种方式， 那么到底是encode decode这种快，还是自定义的快呢？benchmark一下看看。</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">func BenchmarkDeepCopyWithPointer(b *testing.B) {
	for _, c := range cases1 {
		for n := 0; n &lt; b.N; n++ {
			DeepCopyPersonWithPointer(c.input)
		}
	}

}

func BenchmarkDeepCopyWithPointerByJson(b *testing.B) {
	for _, c := range cases1 {
		for n := 0; n &lt; b.N; n++ {
			DeepCopyPersonWithPointerByJson(c.input)
		}
	}

}</pre>



<p>benchmark结果</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="212" src="https://syncdown.github.io/wp-content/uploads/2024/06/image-3-1024x212.png" alt="" class="wp-image-194" srcset="https://syncdown.github.io/wp-content/uploads/2024/06/image-3-1024x212.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/06/image-3-300x62.png 300w, https://syncdown.github.io/wp-content/uploads/2024/06/image-3-768x159.png 768w, https://syncdown.github.io/wp-content/uploads/2024/06/image-3-1536x319.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/06/image-3.png 1572w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>执行的时候运行 go test -bench=被测试方法前缀。</p>



<p>从性能上看，从已有的instance进行深拷贝，用自定义的方法比json encode decode要快了三个数量级。</p>



<p>就是DeepCopyPersonWithPointer要比DeepCopyPersonWithPointerByJson快得多。</p>



<p>我使用的struct比较简单，如果是面对复杂一些的真实业务的场景，可能相差的性能会更大。</p>



<p>结论：</p>



<ol>
<li class="has-regular-font-size">原型复制有两种方式，一种是基于struct结构，一种是基于已有的instance把它作为种子进行拷贝</li>



<li class="has-regular-font-size">golang复制默认就是值传递</li>



<li class="has-regular-font-size">自定义的struct如果有指针类型，用自制的方法，细粒度到指针的子字段级别</li>



<li class="has-regular-font-size">相对于encode decode的深拷贝，自制的方法性能会更好</li>
</ol>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>多个github账号的写入</title>
		<link>https://syncdown.github.io/%e5%a4%9a%e4%b8%aagithub%e8%b4%a6%e5%8f%b7%e7%9a%84%e5%86%99%e5%85%a5/</link>
		
		<dc:creator><![CDATA[Zhenyu Chen]]></dc:creator>
		<pubDate>Sun, 02 Jun 2024 06:59:45 +0000</pubDate>
				<category><![CDATA[技术]]></category>
		<category><![CDATA[git]]></category>
		<category><![CDATA[ssh]]></category>
		<guid isPermaLink="false">https://syncdown.github.io/?p=179</guid>

					<description><![CDATA[不排除一个用户有多个github账号的情况，当进行remote repository的写入的时候，很可能会因为多个github账号而导致push失败的情况。 比如，我有两个github账号， 一个叫tigbox，一个叫syncdown。ssh-keygen -t [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>不排除一个用户有多个github账号的情况，当进行remote repository的写入的时候，很可能会因为多个github账号而导致push失败的情况。 </p>



<p>比如，我有两个github账号， 一个叫tigbox，一个叫syncdown。ssh-keygen -t rsa分别生成了各自的公私密钥对。默认全局的是tigbox，毕竟~/.ssh/id_rsa就是tigbox账号的。</p>



<p>git clone了syncdown.github.io是没有问题的， 因为这个repository是public的，谁都可以读取。</p>



<p>但是在提交的时候， 就出现了如下的问题，显示premission denied to tigbox。</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="171" src="https://syncdown.github.io/wp-content/uploads/2024/06/image-1024x171.png" alt="" class="wp-image-181" srcset="https://syncdown.github.io/wp-content/uploads/2024/06/image-1024x171.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/06/image-300x50.png 300w, https://syncdown.github.io/wp-content/uploads/2024/06/image-768x128.png 768w, https://syncdown.github.io/wp-content/uploads/2024/06/image.png 1344w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>这么看，就清晰多了。syncdown的repository在提交的时候发现是tigbox的github账号，经典的跑偏啊，而跑偏最初始的原因就是因为默认是~/.ssh/id_rsa，那似乎如何引导鉴权程序去使用syncdown的ssh key file就是关键，ssh key file ->github 账号 </p>



<p>编辑~/.ssh/config文件， 把它搞成大概下面的样子。就是两个账号的管理，主要是依靠IdentityFile进行区分的</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="804" height="462" src="https://syncdown.github.io/wp-content/uploads/2024/06/image-1.png" alt="" class="wp-image-183" srcset="https://syncdown.github.io/wp-content/uploads/2024/06/image-1.png 804w, https://syncdown.github.io/wp-content/uploads/2024/06/image-1-300x172.png 300w, https://syncdown.github.io/wp-content/uploads/2024/06/image-1-768x441.png 768w" sizes="(max-width: 804px) 100vw, 804px" /></figure>



<p>回到当前的本地的repository目录，查看并添加ssh IdentityFile</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="131" src="https://syncdown.github.io/wp-content/uploads/2024/06/image-2-1024x131.png" alt="" class="wp-image-185" srcset="https://syncdown.github.io/wp-content/uploads/2024/06/image-2-1024x131.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/06/image-2-300x38.png 300w, https://syncdown.github.io/wp-content/uploads/2024/06/image-2-768x98.png 768w, https://syncdown.github.io/wp-content/uploads/2024/06/image-2.png 1280w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>之后就能顺利的进行提交了，毕竟通过IdentityFile已经能区分出github的账号。</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>GPT-Sovits使用</title>
		<link>https://syncdown.github.io/gpt-sovits%e4%bd%93%e9%aa%8c/</link>
		
		<dc:creator><![CDATA[Zhenyu Chen]]></dc:creator>
		<pubDate>Thu, 18 Apr 2024 11:19:53 +0000</pubDate>
				<category><![CDATA[技术]]></category>
		<category><![CDATA[AI]]></category>
		<category><![CDATA[TTS]]></category>
		<category><![CDATA[声音克隆]]></category>
		<guid isPermaLink="false">https://syncdown.github.io/?p=158</guid>

					<description><![CDATA[AI时代，要是不搞点人工智能方面的东西，作为技术人员碰面了都不好意思跟人打交道。当然之前也零星搞过一些皮毛，但是时间一长就忘记了。 自诩天生对声音敏感，那么AGI就从声音开始进行记录吧。AI和声音相关的有很多，如果是生成的话，主要分TTS（文本转语音）和RVC（声音转声音），本文的重点就是TTS，目前当红炸子鸡就是https://github.com/RVC-Boss/GPT-SoVITS 为什么叫GPT-Sovits？ GPT是生成式预训练变换器的缩写，show for [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>AI时代，要是不搞点人工智能方面的东西，作为技术人员碰面了都不好意思跟人打交道。当然之前也零星搞过一些皮毛，但是时间一长就忘记了。</p>



<p>自诩天生对声音敏感，那么AGI就从声音开始进行记录吧。AI和声音相关的有很多，如果是生成的话，主要分TTS（文本转语音）和RVC（声音转声音），本文的重点就是TTS，目前当红炸子鸡就是<a href="https://github.com/RVC-Boss/GPT-SoVITS">https://github.com/RVC-Boss/GPT-SoVITS</a> </p>



<h4 class="wp-block-heading">为什么叫GPT-Sovits？</h4>



<p>GPT是生成式预训练变换器的缩写，show for Generative Pre-trained Transformer，并不是openai公司的专属。Sovits本身是中国本土的歌声合成爱好者Rcell基于VITS、soft-vc、VISinger2等项目开发的开源程序，不知为何他删除了自己的仓库，后来由svc-develop-team这个账号进行维护。</p>



<p>而我们今天的主角RVC-Boss（B站的名字叫花儿不哭）就是借鉴了Sovits和GPT，所以名字就叫GPT-Sovits，看来人家起的名字还是挺贴切的。另外花儿不哭和Rcell是因为RVC项目而结识的，据说他们灵魂讨论了不下百次。</p>



<p>Sovits的项目地址<a href="https://github.com/svc-develop-team/so-vits-svc">https://github.com/svc-develop-team/so-vits-svc</a> 不过现在已经是存档的状态了（只读）</p>



<h4 class="wp-block-heading">GPT-Sovits有啥用？</h4>



<ul>
<li>短时声音样本，对外宣传是5秒钟的声音即可。</li>



<li>训练时间短，1分钟即可完成训练。其实整个过程分十多步，即便单独把训练单独拎出来说，也不是1分钟就能完成的。尤其是GPT模型的训练。话说回来，还是要肯定这个项目的，起码比闭源的字节跳动要敞亮多了。
<ul>
<li>语音切分</li>



<li>语音降噪</li>



<li>ASR</li>



<li>语音文本标注</li>



<li>文本获取</li>



<li>自监督特征提取</li>



<li>音色token提取</li>



<li>Sovits模型训练</li>



<li>GPT模型训练</li>



<li>推理：选择好Sovits模型和GPT模型</li>
</ul>
</li>



<li>语言支持英日中，实际推理过程中如果出现中英混杂的情况，可能会崩掉</li>



<li></li>
</ul>



<p>注意，作者说<strong>在 Mac 上使用 GPU 训练的模型效果显著低于其他设备训练的模型，所以我们暂时使用CPU进行训练。</strong></p>



<p>应该是笔误，说的是只使用CPU进行训练，怪不得说慢呢。</p>



<p>即便如此，目前能找到的声音样本少，效果好的就是GPT-Sovits项目，非常良心。</p>



<h4 class="wp-block-heading">GPT-Sovits的安装</h4>



<ol>
<li><code>xcode-select --install</code>&nbsp;安装 Xcode command-line tools</li>



<li><code>brew install ffmpeg</code>&nbsp;或&nbsp;<code>conda install ffmpeg</code>&nbsp;安装 FFmpeg</li>



<li>conda里面安装依赖
<ul>
<li>conda create -n GPTSoVits python=3.9</li>



<li>conda activate GPTSoVits</li>



<li>pip install -r requirements.txt 或者python3.9 -m pip install -r requirements.txt</li>
</ul>
</li>



<li>下载模型&nbsp;<a href="https://huggingface.co/lj1995/GPT-SoVITS">GPT-SoVITS Models</a>&nbsp;下载预训练模型，并将它们放置在&nbsp; 项目目录\<code>GPT_SoVITS\pretrained_models</code></li>
</ol>



<h4 class="wp-block-heading">GPT-Sovits的启动</h4>



<p>没什么好说的， python webui.py就是启动命令</p>



<h4 class="wp-block-heading">另一种方式：Docker compose启动方式（不推荐，尝试一下就好）</h4>



<ol>
<li>修改docker-compser.yaml </li>
</ol>



<p>因为我的电脑是mac的， 由于m1的GPU存在内存泄露的情况， 所以不用GPU训练，devices: [] 写成空list，不然会报错，说什么reservations.devices必须是list列表形式。</p>



<p>因为电脑是arm64架构的， 配置内容和image平级的， 添加一个platform: linux/arm64配置项</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="439" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-37-1024x439.png" alt="" class="wp-image-165" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-37-1024x439.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-37-300x129.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-37-768x329.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-37.png 1484w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>不过目前还没有arm64架构的image</p>



<p>2. docker compose -f docker-compose.yaml up -d</p>



<p>但是没想到压根就没有arm64平台的</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="81" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-38-1024x81.png" alt="" class="wp-image-166" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-38-1024x81.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-38-300x24.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-38-768x61.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-38-1536x121.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-38-2048x162.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>算了， 配置项里面删除掉platform，再试试看。</p>



<p>倒是能启动了， 也能训练，就是推理页面打不开，并且页面的打开要靠手动输入地址。比如初始页面，标注页面等等，页面UI也没有做中文本地化。</p>



<p>看完Docker Compose这部分，还是建议不要使用这种方式了。</p>



<h4 class="wp-block-heading">模型训练</h4>



<p>语音包就是datasets，第一步就是对训练数据做一些预处理</p>



<p>1、人声分离（optional）</p>



<p>尽量找高质量的干音，训练数据的质量越好最终的效果也就越好。如果实在是找不到UVR人声分离就派上用场了。</p>



<p>2、语音切分</p>



<p>将路径下的所有文件按照统一的制式进行切割，具体里面涉及很多参数细节，默认就好</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="484" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-39-1024x484.png" alt="" class="wp-image-169" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-39-1024x484.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-39-300x142.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-39-768x363.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-39-1536x726.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-39-2048x968.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>3、语音降噪（optional）</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="129" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-40-1024x129.png" alt="" class="wp-image-170" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-40-1024x129.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-40-300x38.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-40-768x97.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-40-1536x194.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-40-2048x258.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>4、ASR</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="411" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-41-1024x411.png" alt="" class="wp-image-171" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-41-1024x411.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-41-300x120.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-41-768x308.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-41-1536x616.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-41-2048x821.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>要填写输入路径，ASR完成后需要进行人工校验，填写.list文件路径之后勾选「是否开启打标webui」，然后程序会单独新开一个tab窗口，校对好之后提交更改，其实最后是对.list文件进行了修改。</p>



<p>5、训练集格式化</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="611" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-42-1024x611.png" alt="" class="wp-image-172" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-42-1024x611.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-42-300x179.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-42-768x458.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-42-1536x916.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-42-2048x1222.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>以mac m2为例， 没必要填写GPU卡</p>



<p>6、 模型训练</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="582" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-43-1024x582.png" alt="" class="wp-image-173" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-43-1024x582.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-43-300x170.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-43-768x436.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-43-1536x872.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-43-2048x1163.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>7、 推理</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="389" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-44-1024x389.png" alt="" class="wp-image-174" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-44-1024x389.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-44-300x114.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-44-768x292.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-44-1536x584.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-44-2048x778.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>选择两个模型，都在一个实验下。 </p>



<p>勾选「是否开启TTS推理WebUI」，程序会帮你打开9872这个端口的页面，然后就可以开始推理了。</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="623" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-45-1024x623.png" alt="" class="wp-image-175" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-45-1024x623.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-45-300x183.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-45-768x467.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-45-1536x935.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-45-2048x1246.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p></p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>retool查询Mongodb Atlas</title>
		<link>https://syncdown.github.io/retool%e6%9f%a5%e8%af%a2mongodb-atlas/</link>
		
		<dc:creator><![CDATA[Zhenyu Chen]]></dc:creator>
		<pubDate>Fri, 12 Apr 2024 10:41:32 +0000</pubDate>
				<category><![CDATA[技术]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[retool]]></category>
		<guid isPermaLink="false">https://syncdown.github.io/?p=155</guid>

					<description><![CDATA[Mongodb Atlas可以托管一个免费的mongo实例，retool呢几乎也是免费的。 几分钟这俩就可以拼凑出一个简单的数据查询页面。 未完待续]]></description>
										<content:encoded><![CDATA[
<p></p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="757" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-36-1024x757.png" alt="" class="wp-image-156" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-36-1024x757.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-36-300x222.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-36-768x567.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-36.png 1432w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>Mongodb Atlas可以托管一个免费的mongo实例，retool呢几乎也是免费的。 </p>



<p>几分钟这俩就可以拼凑出一个简单的数据查询页面。</p>



<p>未完待续</p>



<p></p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>多账号就要承受账号管理的风险</title>
		<link>https://syncdown.github.io/%e5%a4%9a%e8%b4%a6%e5%8f%b7%e5%b0%b1%e8%a6%81%e6%89%bf%e5%8f%97%e8%b4%a6%e5%8f%b7%e7%ae%a1%e7%90%86%e7%9a%84%e9%a3%8e%e9%99%a9/</link>
		
		<dc:creator><![CDATA[Zhenyu Chen]]></dc:creator>
		<pubDate>Thu, 11 Apr 2024 04:07:59 +0000</pubDate>
				<category><![CDATA[冷知识]]></category>
		<category><![CDATA[apple]]></category>
		<guid isPermaLink="false">https://syncdown.github.io/?p=140</guid>

					<description><![CDATA[早上刚醒就发现微信半夜推送的支付通知：一笔98元的扣费 瞬间清醒，起床气加成。 凌晨3点47啊 尼玛，这个时候大多数人都在睡觉吧。我花钱了？干啥了？ 显示是apple相关的，在手机app [&#8230;]]]></description>
										<content:encoded><![CDATA[
<div class="wp-block-media-text is-stacked-on-mobile" style="grid-template-columns:28% auto"><figure class="wp-block-media-text__media"><img loading="lazy" decoding="async" width="536" height="1024" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-32-536x1024.png" alt="" class="wp-image-142 size-full" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-32-536x1024.png 536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-32-157x300.png 157w, https://syncdown.github.io/wp-content/uploads/2024/04/image-32-768x1468.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-32-804x1536.png 804w, https://syncdown.github.io/wp-content/uploads/2024/04/image-32.png 830w" sizes="(max-width: 536px) 100vw, 536px" /></figure><div class="wp-block-media-text__content">
<p class="has-regular-font-size">早上刚醒就发现微信半夜推送的支付通知：一笔98元的扣费</p>



<p class="has-regular-font-size">瞬间清醒，起床气加成。</p>



<p>凌晨3点47啊</p>



<p>尼玛，这个时候大多数人都在睡觉吧。我花钱了？干啥了？</p>



<p></p>
</div></div>



<p>显示是apple相关的，在手机app store上赶紧查看一下自己的购买记录。</p>



<div class="wp-block-media-text is-stacked-on-mobile"><figure class="wp-block-media-text__media"><img loading="lazy" decoding="async" width="858" height="780" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-33.png" alt="" class="wp-image-143 size-full" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-33.png 858w, https://syncdown.github.io/wp-content/uploads/2024/04/image-33-300x273.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-33-768x698.png 768w" sizes="(max-width: 858px) 100vw, 858px" /></figure><div class="wp-block-media-text__content">
<p>时间对的上。。。</p>



<p>金额对的上。。。</p>



<p>我确实记得曾经对这个叫paste的软件做了订阅，现在想想虽然它很有用，但是不值这个钱。</p>



<p>赶紧操作一下，取消订阅，还有马上申请退款。</p>
</div></div>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="404" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-35-1024x404.png" alt="" class="wp-image-153" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-35-1024x404.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-35-300x118.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-35-768x303.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-35-1536x606.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-35.png 1658w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>回过头来看这个事情还挺有趣的，我承认自己的账号管理方面有问题、比较薄弱，但这个不是我想说的重点。而是苹果这套生态系统，如果我有多个账号， 而曾经购买并订阅了这个app的账号目前恰好不用了呢？凑巧账号绑定的是信用卡支付，岂不是意味着账单出具的时候才会发现这笔付款！</p>



<p>正常情况下app需要AppleID登录的情况下从AppStore下载，但是同一<strong>设备的AppleID即便更换了，之前下载的app是仍旧可以继续使用的</strong>，这个怎么说呢，用户体验也挺好的。只是在mac电脑上，登录过很多AppleID的话，是不能知晓当前app是哪个AppleID下载的。</p>



<p></p>



<p>比如早上说的这种情况，因为有订阅的订单，订单会明确谁在什么时候，花了多少钱，买了什么 ，当然这是微信支付记录的，微信帮你确定了Apple ID 和app名称，微信支付还是做的不错的。</p>



<figure class="wp-block-image size-full is-resized"><img loading="lazy" decoding="async" width="680" height="624" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-34.png" alt="" class="wp-image-148" style="width:252px;height:auto" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-34.png 680w, https://syncdown.github.io/wp-content/uploads/2024/04/image-34-300x275.png 300w" sizes="(max-width: 680px) 100vw, 680px" /></figure>



<p>但是倘若是没有订单或者是有苹果订单，但是AppleID没有登录，订单没有收到。光是想知道app是哪个AppleID下载订阅的，似乎就没有太好的办法了。</p>



<p>比如你有多个AppleID账号（为什么会是多个呢，科学上网、国内国外两套很正常）</p>



<p>在一台mac设备上，先后登录了 路人甲乙丙 三个AppleID账号；2023年，a账号登录并下载了某APP；2024年b账号登录，这个APP依旧可以正常使用。</p>



<ul>
<li><em>如果你从AppleID来查看所有已经购买及订阅的app，是完全没有问题的。</em></li>



<li><em>如果你想app的角度，在当前mac上，查当时是谁下载的，我还没有找到很好的办法。</em></li>
</ul>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="609" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-31-1024x609.png" alt="" class="wp-image-141" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-31-1024x609.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-31-300x178.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-31-768x457.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-31.png 1382w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>想象一下，假如a账号目前没有登录在任何设备上，碰到今天扣款的问题，我肯定就不能这么快查到。我大概会这么查</p>



<p>登录路人甲账号，查看购买。。。</p>



<p>登录路人乙账号，查看购买。。。</p>



<p>登录路人丙账号，查看购买。。。</p>



<p>登录a账号，查看购买。。。（查到了，原来tm的是这个账号下载的）</p>



<p>那如果我有<mark style="background-color:rgba(0, 0, 0, 0)" class="has-inline-color has-orange-color">上百</mark>个账号呢。。。┓( ´∀` )┏。。。</p>



<p></p>



<p></p>



<p></p>



<p></p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>本博客的技术垫脚石：wordpress和github pages来建静态网站（二）</title>
		<link>https://syncdown.github.io/%e6%9c%ac%e5%8d%9a%e5%ae%a2%e7%9a%84%e6%8a%80%e6%9c%af%e5%9e%ab%e8%84%9a%e7%9f%b3%ef%bc%9awordpress%e5%92%8cgithub-pages%e6%9d%a5%e5%bb%ba%e9%9d%99%e6%80%81%e7%bd%91%e7%ab%99-2/</link>
		
		<dc:creator><![CDATA[Zhenyu Chen]]></dc:creator>
		<pubDate>Tue, 09 Apr 2024 11:18:16 +0000</pubDate>
				<category><![CDATA[技术]]></category>
		<category><![CDATA[github pages]]></category>
		<category><![CDATA[wordpress]]></category>
		<category><![CDATA[静态博客]]></category>
		<guid isPermaLink="false">https://syncdown.github.io/?p=92</guid>

					<description><![CDATA[上回书我们说到为了实践费曼学习法而用静态方式来搭建wordpress并最终发布。其中的关键就是导出网站前端三剑客，然后将静态文件部署到github.io上。 我们先把github的东西搞定。 创建一个名叫username.github.io的仓库 名字很重要，开始就起好，即使没起好后面也不要变。 在github上没抢注到syncup这个username，反其道就叫syncdown，喻义“同步回滚”。repository的名字就叫syncdown.github.io [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>上回书我们说到为了实践费曼学习法而用静态方式来搭建wordpress并最终发布。其中的关键就是导出网站前端三剑客，然后将静态文件部署到github.io上。</p>



<p>我们先把github的东西搞定。</p>



<h2 class="wp-block-heading">创建一个名叫username.github.io的仓库</h2>



<p><strong>名字很重要，开始就起好，即使没起好后面也不要变。</strong></p>



<p>在github上没抢注到syncup这个username，反其道就叫syncdown，喻义“同步回滚”。repository的名字就叫<mark style="background-color:rgba(0, 0, 0, 0)" class="has-inline-color has-orange-color">syncdown.github.io</mark></p>



<p>切记这个repsitory的可见性要设置成public的，如果设置成private的，会在后续的deploy环节获取不到对应的资源。想想也对，后续的CICD流程触发起来的deploy action会去repository中获取数据，虽然都是github平台的事情，但github action此时就好比一个第三方流程，如果是你的仓库是private的话，肯定获取不到资源的。如同代码包中的类的可见性。</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="425" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-21-1024x425.png" alt="" class="wp-image-101" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-21-1024x425.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-21-300x124.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-21-768x319.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-21-1536x637.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-21-2048x849.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<ul>
<li>如果是新创建的repository，没什么好说的，public就好。</li>



<li>如果是已经创建的repository，可见性已经设置成private的，那也可以改成public的。</li>
</ul>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="558" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-20-1024x558.png" alt="" class="wp-image-98" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-20-1024x558.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-20-300x163.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-20-768x418.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-20-1536x837.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-20.png 1950w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<h2 class="wp-block-heading">设置repository中github actions的workflow</h2>



<p>设置repository中github actions的workflow，<strong>说人话</strong>就是，每当repository有代码提交就会触发一个workflow工作流，这个工作流我们要选择deploy部署，也就是把静态资源部署到github的CDN中。</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="340" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-23-1024x340.png" alt="" class="wp-image-103" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-23-1024x340.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-23-300x100.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-23-768x255.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-23-1536x511.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-23-2048x681.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="201" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-24-1024x201.png" alt="" class="wp-image-104" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-24-1024x201.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-24-300x59.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-24-768x151.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-24-1536x301.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-24-2048x402.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="466" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-25-1024x466.png" alt="" class="wp-image-105" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-25-1024x466.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-25-300x137.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-25-768x349.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-25-1536x699.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-25-2048x932.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>github pages提供了static html的工作流模板，分支默认是main，也就是说main branch的代码提交才会触发这个workflow。不用做任何修改，提交就用。</p>



<p>本地git clone，然后<strong>记录代码路径后续有用的</strong>，为了好表示就暂且搞成<mark style="background-color:rgba(0, 0, 0, 0)" class="has-inline-color has-orange-color">~/code/syncdown.github.io</mark></p>



<p>做完了github这边的事情，再回来到wordpress。</p>



<p>既然是wordpress产生的静态文件要部署到github.io，那就要把静态文件导出到<mark style="background-color:rgba(0, 0, 0, 0)" class="has-inline-color has-orange-color">~/code/syncdown.github.io</mark>。</p>



<h2 class="wp-block-heading">安装WP插件Simply Static</h2>



<p>wordpress提供了很多开源的插件， 其中就有导出静态文件需要的插件&#8212;&#8212;Simply Static</p>



<p>在wp admin左侧列表页里面的Plugins按图索骥，一步一步找到Simply Static，找到就能安装上，然后别忘记active。</p>



<div class="wp-block-columns is-layout-flex wp-container-core-columns-is-layout-2 wp-block-columns-is-layout-flex">
<div class="wp-block-column is-layout-flow wp-block-column-is-layout-flow">
<figure class="wp-block-image size-full is-resized"><img loading="lazy" decoding="async" width="764" height="372" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-18.png" alt="" class="wp-image-94" style="width:386px;height:auto" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-18.png 764w, https://syncdown.github.io/wp-content/uploads/2024/04/image-18-300x146.png 300w" sizes="(max-width: 764px) 100vw, 764px" /></figure>
</div>



<div class="wp-block-column is-layout-flow wp-block-column-is-layout-flow">
<figure class="wp-block-image size-large is-resized"><img loading="lazy" decoding="async" width="1024" height="334" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-19-1024x334.png" alt="" class="wp-image-95" style="width:576px;height:auto" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-19-1024x334.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-19-300x98.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-19-768x251.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-19-1536x502.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-19-2048x669.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>
</div>
</div>



<h2 class="wp-block-heading">配置Simply Static</h2>



<p>安装好这个插件之后，在wordpress的admin管理页面对应的网站就是当前的syncdown了。</p>



<p>replacing urls选择绝对路径，填写好你的username.github.io</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="588" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-26-1024x588.png" alt="" class="wp-image-116" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-26-1024x588.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-26-300x172.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-26-768x441.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-26-1536x882.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-26-2048x1177.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>在deploy部署一项中，路径写刚刚git clone到本地的<mark style="background-color:rgba(0, 0, 0, 0)" class="has-inline-color has-orange-color">~/code/syncdown.github.io</mark></p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="501" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-27-1024x501.png" alt="" class="wp-image-117" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-27-1024x501.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-27-300x147.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-27-768x375.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-27-1536x751.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-27-2048x1001.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<h2 class="wp-block-heading">用Simply Static导出到本地github触发提交</h2>



<p>配置都已经好了，就放心大胆的导出静态文件吧。按照预期静态文件会导出到本地的github</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="480" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-28-1024x480.png" alt="" class="wp-image-118" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-28-1024x480.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-28-300x141.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-28-768x360.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-28-1536x720.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-28-2048x961.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>之后大胆的git push触发github workflow，如果顺利的话在github用户页面中可以查看到此次build的信息。</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="505" src="https://syncdown.github.io/wp-content/uploads/2024/04/image-29-1024x505.png" alt="" class="wp-image-119" srcset="https://syncdown.github.io/wp-content/uploads/2024/04/image-29-1024x505.png 1024w, https://syncdown.github.io/wp-content/uploads/2024/04/image-29-300x148.png 300w, https://syncdown.github.io/wp-content/uploads/2024/04/image-29-768x379.png 768w, https://syncdown.github.io/wp-content/uploads/2024/04/image-29-1536x757.png 1536w, https://syncdown.github.io/wp-content/uploads/2024/04/image-29-2048x1010.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>至此最核心的几个流程都已经描述完了，最后打开你的username.github.io来检查一下吧。</p>



<h4 class="wp-block-heading">如何设置文章的头图</h4>



<p>文章的头图可能会带给用户aha时刻，对运营同学而言是至关重要的一步，不过这个文章的头图设置还是很难找的，如下</p>



<figure class="wp-block-video"><video controls src="https://syncdown.github.io/wp-content/uploads/2024/04/Filmage-2024-04-10_100412.mp4"></video></figure>



<p></p>
]]></content:encoded>
					
		
		<enclosure url="https://syncdown.github.io/wp-content/uploads/2024/04/Filmage-2024-04-10_100412.mp4" length="3711840" type="video/mp4" />

			</item>
	</channel>
</rss>
